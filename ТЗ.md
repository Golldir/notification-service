# Техническое задание: Система уведомлений

## 1. Общее описание

Система для отправки уведомлений пользователям через различные каналы связи с обеспечением надежной доставки через fallback-механизм.

## 2. Технический стек

### Backend
- **FastAPI** - веб-фреймворк для API
- **UV** - менеджер пакетов и зависимостей Python
- **SQLAlchemy** - ORM для работы с БД
- **Alembic** - миграции БД
- **Pydantic** - валидация данных
- **Pytest** - тестирование

### База данных
- **PostgreSQL** - основная БД (или SQLite для MVP)

### Интеграции
- **Email**: SMTP (или SendGrid/Resend API для production)
- **SMS**: Twilio API (или альтернативный провайдер)
- **Telegram**: Telegram Bot API

### Инфраструктура
- **Redis** (опционально) - для очередей задач и кеширования
- **Celery** (опционально) - для асинхронной обработки задач
- **Docker** - контейнеризация

### Дополнительно
- **python-dotenv** - управление переменными окружения
- **httpx** / **aiohttp** - асинхронные HTTP-запросы
- **loguru** / **structlog** - логирование
- **prometheus-fastapi-instrumentator** (опционально) - метрики

## 3. Функциональные требования

### 3.1. Каналы доставки

#### 3.1.1. Email
- Отправка текстовых и HTML писем
- Поддержка темы письма (subject)
- Поддержка отправителя (from_email)
- Валидация email адресов
- Обработка ошибок SMTP/API провайдера

#### 3.1.2. SMS
- Отправка текстовых сообщений
- Ограничение длины сообщения (обычно 160 символов, поддержка длинных)
- Валидация телефонных номеров
- Обработка ошибок API провайдера

#### 3.1.3. Telegram
- Отправка сообщений через Telegram Bot API
- Поддержка форматирования (Markdown/HTML, опционально)
- Требуется chat_id получателя
- Обработка ошибок Bot API

### 3.2. Механизм надежной доставки (Fallback)

**Принцип работы:**
1. При отправке уведомления указывается приоритетный канал
2. При неудаче выполняется автоматический переход на следующий канал по приоритету
3. Дефолтный порядок fallback: **Email → SMS → Telegram**
4. Порядок fallback настраивается при создании уведомления

**Стратегия retry:**
- Максимум 3 попытки на каждый канал
- Экспоненциальная задержка между попытками: 1s, 2s, 4s
- После исчерпания попыток на канале - переход к следующему
- Если все каналы исчерпаны - уведомление помечается как failed

### 3.3. API endpoints

#### 3.3.1. Отправка уведомления
```
POST /api/v1/notifications/send
```

**Request Body:**
```json
{
  "user_id": "string (optional)",
  "recipient": {
    "email": "user@example.com",
    "phone": "+1234567890",
    "telegram_chat_id": "123456789"
  },
  "message": {
    "subject": "Notification Subject",
    "body": "Notification body text",
    "body_html": "<html>...</html> (optional)"
  },
  "channels": ["email", "sms", "telegram"],  // Приоритетный порядок
  "priority": "high" | "medium" | "low"  // Опционально
}
```

**Response:**
```json
{
  "notification_id": "uuid",
  "status": "pending" | "sent" | "failed",
  "channel_used": "email" | "sms" | "telegram",
  "timestamp": "2024-01-01T12:00:00Z"
}
```

#### 3.3.2. Статус уведомления
```
GET /api/v1/notifications/{notification_id}/status
```

**Response:**
```json
{
  "notification_id": "uuid",
  "status": "sent" | "failed" | "pending",
  "channel_used": "email",
  "attempts": [
    {
      "channel": "email",
      "status": "failed",
      "error": "SMTP connection timeout",
      "timestamp": "2024-01-01T12:00:00Z"
    },
    {
      "channel": "sms",
      "status": "sent",
      "timestamp": "2024-01-01T12:00:05Z"
    }
  ],
  "final_status": "sent",
  "created_at": "2024-01-01T12:00:00Z",
  "delivered_at": "2024-01-01T12:00:05Z"
}
```

#### 3.3.3. История уведомлений
```
GET /api/v1/notifications?user_id={user_id}&limit=50&offset=0
```

#### 3.3.4. Health check
```
GET /health
```

### 3.4. Хранение данных

**Таблица: notifications**
- id (UUID, primary key)
- user_id (string, nullable)
- recipient_email (string, nullable)
- recipient_phone (string, nullable)
- recipient_telegram_id (string, nullable)
- subject (string, nullable)
- body_text (text)
- body_html (text, nullable)
- status (enum: pending, sent, failed)
- channel_used (enum: email, sms, telegram, null)
- priority (enum: high, medium, low)
- created_at (timestamp)
- delivered_at (timestamp, nullable)
- error_message (text, nullable)

**Таблица: notification_attempts**
- id (UUID, primary key)
- notification_id (UUID, foreign key)
- channel (enum: email, sms, telegram)
- status (enum: success, failed)
- error_message (text, nullable)
- attempt_number (integer)
- timestamp (timestamp)
- response_data (jsonb, nullable)

### 3.5. Конфигурация

Все настройки через переменные окружения (.env):
- База данных (DATABASE_URL)
- SMTP настройки (SMTP_HOST, SMTP_PORT, SMTP_USER, SMTP_PASSWORD)
- SMS провайдер (TWILIO_ACCOUNT_SID, TWILIO_AUTH_TOKEN, TWILIO_PHONE_NUMBER)
- Telegram (TELEGRAM_BOT_TOKEN)
- Логирование (LOG_LEVEL)
- Режим работы (ENVIRONMENT: development/production)

## 4. Нефункциональные требования

### 4.1. Производительность
- Обработка уведомлений должна быть асинхронной
- Поддержка batch отправки (опционально для MVP)
- Timeout для каждого канала: 10 секунд

### 4.2. Надежность
- Все ошибки логируются
- Retry механизм с экспоненциальной задержкой
- Fallback на альтернативные каналы

### 4.3. Безопасность
- Валидация всех входных данных
- Защита от SQL injection (ORM)
- Rate limiting на API endpoints (опционально для MVP)
- Секреты только в переменных окружения

### 4.4. Логирование
- Структурированное логирование всех операций
- Уровни: DEBUG, INFO, WARNING, ERROR
- Логирование попыток доставки с деталями

### 4.5. Тестирование
- Unit тесты для бизнес-логики
- Integration тесты для API endpoints
- Тесты для fallback механизма
- Mock для внешних API (SMTP, SMS, Telegram)

## 5. Архитектура

### 5.1. Структура проекта
```
test-notif/
├── app/
│   ├── __init__.py
│   ├── main.py                 # FastAPI приложение
│   ├── config.py               # Конфигурация
│   ├── models/                 # SQLAlchemy модели
│   │   ├── __init__.py
│   │   └── notification.py
│   ├── schemas/                # Pydantic схемы
│   │   ├── __init__.py
│   │   └── notification.py
│   ├── api/                    # API endpoints
│   │   ├── __init__.py
│   │   └── v1/
│   │       ├── __init__.py
│   │       └── notifications.py
│   ├── services/               # Бизнес-логика
│   │   ├── __init__.py
│   │   ├── notification_service.py
│   │   └── channels/
│   │       ├── __init__.py
│   │       ├── base.py         # Базовый класс канала
│   │       ├── email.py
│   │       ├── sms.py
│   │       └── telegram.py
│   ├── db/                     # Работа с БД
│   │   ├── __init__.py
│   │   ├── session.py
│   │   └── base.py
│   └── utils/
│       ├── __init__.py
│       └── validators.py
├── tests/
│   ├── __init__.py
│   ├── test_api/
│   ├── test_services/
│   └── conftest.py
├── alembic/                    # Миграции
├── .env.example
├── .gitignore
├── pyproject.toml              # UV конфигурация
├── README.md
└── docker-compose.yml          # Опционально
```

### 5.2. Основные компоненты

1. **NotificationService** - основная логика отправки с fallback
2. **Channel providers** - отдельные классы для каждого канала
3. **API layer** - FastAPI endpoints
4. **Database layer** - SQLAlchemy модели и репозитории

## 6. Этапы реализации

### Этап 1: Базовая инфраструктура (4-6 часов)
- Настройка проекта с UV
- FastAPI приложение с базовыми endpoints
- Настройка БД (SQLAlchemy + Alembic)
- Конфигурация через .env

### Этап 2: Реализация каналов (6-8 часов)
- Базовый класс Channel
- Email channel (SMTP)
- SMS channel (Twilio)
- Telegram channel (Bot API)
- Unit тесты для каналов

### Этап 3: Сервис уведомлений с fallback (4-6 часов)
- NotificationService с логикой fallback
- Retry механизм
- Сохранение в БД
- Integration тесты

### Этап 4: API и финализация (4-6 часов)
- Полные API endpoints
- Валидация данных
- Логирование
- Документация API
- README с инструкциями

**Общее время: 18-26 часов (2-3 рабочих дня)**

## 7. Дополнительные возможности (если останется время)

- Веб-интерфейс для просмотра истории (Streamlit/React)
- Метрики и мониторинг (Prometheus)
- Webhook для статусов доставки
- Шаблоны уведомлений
- Batch отправка
- Очередь задач (Celery + Redis)
- Аутентификация API (JWT)

## 8. Критерии приемки

- [ ] Все три канала (Email, SMS, Telegram) работают
- [ ] Fallback механизм переключается между каналами при ошибках
- [ ] История отправок сохраняется в БД
- [ ] API endpoints работают и документированы
- [ ] Покрытие тестами >= 70%
- [ ] Проект запускается через Docker или локально
- [ ] README с инструкциями по установке и использованию

## 9. Вопросы для уточнения

1. **Провайдеры**: Какие конкретные сервисы использовать для SMS? (Twilio, AWS SNS, другой)
2. **Аутентификация**: Нужна ли аутентификация API или открытый доступ?
3. **Масштаб**: Ожидаемое количество уведомлений в день? (для выбора архитектуры)
4. **БД**: PostgreSQL или SQLite достаточно для MVP?
5. **Deployment**: Планируется ли деплой или только локальная разработка?

---

**Время реализации: до 2 дней**
**Статус: в разработке**
